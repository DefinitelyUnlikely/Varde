Okej, här tänker jag att jag skriver ner mina tankar om hur jag vill jobba med MS Access databasen.
Först behöver jag lista ut hur jag ska få fram relevant data.

Så, vilka problem har jag? 

1. Jag vill kunna ta fram långsiktigt värde för en region under en tidsperiod.
2. Jag vill kunna ta fram första laddningsvärde för en region under en tidsperiod. 
3. Vill jag kunna ta fram totalt laddat värde under en period? Det blir väl bara 1 + 2. Eller gör vi den först, delar upp det sedan?
4. Ta fram gross, dela upp dem i förladdade och tomma.

Vi börjar med dessa problem. När vi löst detta kan vi börja titta på att printa det till excel, att göra jämförelser 
för olika tidsperioder osv. 

Lösning problem 1:

Börja med att ta fram alla nummer och deras laddningsvärde för en period. Spara detta.
Ta sedan fram i vilken butik varje nummer finns. 

Eller jadu, jag borde kanske titta på att göra en join? 

cursor.execute('SELECT * FROM Laddningsdata INNER JOIN Storecheck ON Laddningsdata.MSISDN=Storecheck.Number '
               'WHERE "Topup date" between #10/3/22# and #10/3/22#;')

denna hämtar Laddningsdata och joinar sedan på Storecheck på den. Fördelen med det är att om ett nummer blir laddat
flera gånger bör butiken läggas på varje enskild laddning. 

Just nu provade jag att ha en counter som helt enkelt lägger ihop allt värde för en månad. Det är dock mycket högre 
än det som skickades ut till oss i vår budget när jag jämförde september. Även om jag lade ihop ALLA laddningar till
ett ända stort värde. 

cursor.execute('SELECT Laddningsdata.MSISDN, "Topup date", Measure, "Amount paid", Activated, Storecheck.Region, Store, Chain, Artikel ' 
               'FROM (Laddningsdata INNER JOIN Storecheck ON Laddningsdata.MSISDN=Storecheck.Number) '
               'INNER JOIN SIM_kort ON Storecheck.number=SIM_Kort.MSISDN '
               'WHERE "Topup date" between #09/30/22# and #09/30/22#;')


Jag får helt enkelt kolla igenom min indata samt även att det inte är fel på Angelica och Klaras sida.

region_map = Counter()
store_map = Counter()
first = 0
for i in cursor.fetchall():
    region_map[i.Region] += i.Measure * i.__getattribute__('Amount paid')
    store_map[i.Store] += i.Measure * i.__getattribute__('Amount paid')
    if i.__getattribute__('Topup date') == i.Activated:
        first += i.Measure * i.__getattribute__('Amount paid')



for reg in region_map:
    print(reg, region_map[reg])



FRÅGOR:

Vilken region skall vi använda? Det verkar finnas fler regioner i SIM_kort tabellen. Är de relevanta? Är det dem vi skall nyttja?
Vi ska använda regionen som finns i tabellen Storecheck. KOm ihåg att välja vilka kolumner du vill ha från varje tabell i din
SQL query och välj bort regionen som kommer med SIM_kort.

Jag ser ett problem med min nuvarande strategi också. Det verkar som att de flesta kort har en topup date som är INNAN aktiveringsdatumet.
Oftast dagen innan. Antagligen så att topupen är dagen innan och kortet därmed inte blir inlagt och aktiverat i storecheck förrens dagen 
efter. i.e. vid 8 när man laddar upp en av csv filerna.

Så för att kolla upp värdet för en specifik månad? Första värde kan nog lösas "hyffsat" enkelt isåfall. Vi gör en query för tidsperioden
mot Activated från Storecheck. Vi får då alla kort som aktiverades i tidsintervallet. Då kan vi sedan utnyttja JOIN med Laddningsdata
och få våra kort med tillhörande topup. Bör nog kolla på att jag vill rensa bort topups som hände för längesedan (har vissa från 2019 t.ex.)

Så problemet är långsiktigt värde. Jag får fråga om Viktor hade några kriterier. Minns att han pratat om att de var kort akiverade ett
visst tag tillbaka i tiden. Isåfall gör vi samma sak som ovan fast vi räknar bort första laddningarna. 

Att ta fram gross är ju bara att gå igenom Storecheck? har ett kort blivit aktiverat är det ett gross. Vi lägger in det i rätt region. ENKELT!
För att hålla koll på om det är förladdat eller inte utnyttjar vi att vi kan joina också med SIM_kort. Vi kollar artikel för varje gross innan 
vi lägger in det i en butik eller region. Regionen/butiken får vara en dictionary med två alterantiv gällande grosstyp.

SVAR OM LÅNGSIKTIGT VÄRDE:
långsiktiga är inklusive förstaladdningen och sedan alla laddningar på ett specifikt nummer i ett år. I och med att nummer återanvänds 
räknas inte det mer än ett år bakåt i tiden för att de då kan vara återaktiverade.

Så, långsiktigt värde för en region, hur tar vi då fram det? För ett aktiverat kort, så behöver vi kolla alla laddningar som gjorts på detta,
ett år framåt sedan det aktiverades?

Om vi tänker utan året. Hur hade vi då gjort? Om vi ville veta långsiktiga värdet i en region under en viss period hade jag gått igenom alla
laddningar för den perioden och sedan kollat vilken region numret hör till, för att koppla värdet till den regionen. Särskilt om
första laddning ingår i långsiktigt, för då vill jag ju bara veta vilken region som ska ha värdet lagt på sig och jag vet att laddningen
gjordes nyligen. Det är möjligtvis isåfall om jag OCKSÅ skall kolla, innan jag lägger in värdet i regionen, att kortet inte aktiverades
mer en ett år sedan från senaste datumeti perioden jag undersöker. Det kan förklara varför jag fick MER värde när jag gjorde det ovan
(för det var väl det jag gjorde först, för att testa?)

cursor.execute('SELECT Laddningsdata.MSISDN, "Topup date", Measure, "Amount paid", Activated, Storecheck.Region, Store, Chain, Artikel ' 
               'FROM (Laddningsdata INNER JOIN Storecheck ON Laddningsdata.MSISDN=Storecheck.Number) '
               'INNER JOIN SIM_kort ON Storecheck.number=SIM_Kort.MSISDN '
               'WHERE Activated between #10/03/22# and #10/03/22#;')

cursor.execute(
    'SELECT Number, Store, Storecheck.Region, Activated, "Topup date", Measure, "Amount paid", Artikel '
    'FROM (Storecheck INNER JOIN Laddningsdata ON Storecheck.Number=Laddningsdata.MSISDN) '
    'INNER JOIN SIM_kort ON Laddningsdata.MSISDN=SIM_Kort.MSISDN '
    'WHERE Activated between #09/30/21# and #09/30/22# '
    'AND "Topup date" between #09/30/21# and #09/30/22#'
    )

        one_year_earlier = str(int(to_cal.get_date()[-2:]) - 1)
        earlier_string = f"{to_cal.get_date()[:-2]}{one_year_earlier}"

cursor.execute(
    'SELECT Laddningsdata.MSISDN, Store, Storecheck.Region, Activated, "Topup date", Measure, "Amount paid", Artikel '
    'FROM (Laddningsdata INNER JOIN Storecheck ON Laddningsdata.MSISDN=Storecheck.Number) '
    'INNER JOIN SIM_kort ON Laddningsdata.MSISDN=SIM_Kort.MSISDN '
    f'WHERE "Topup date" between #{from_date}# and #{to_date}#'
    f'AND Activated between #{to_date - relativedelta(years=1)}# and #{to_date}#'
    )

Alright. Dags för första laddningen. Då vill jag ännu en gåg hämta alla nummer. Men denna gången vill 
jag att korten skall ha "Activated" i Storecheck som är samma dag eller dagen efter. (Man säljer laddningen den 23de i månaden säger vi.
Men salsa har redan skapat siffror för dagen, så det aktiverade kortet kommer inte med in i Storecheck tabellen. Däremot kommer den 
att bli tillagd den 24de i månaden.) Eller är det så att man skall kolla om topup datumet är INNAN eller samma som Activated datumet i Storecheck?
Det är nog det bättre alternativet. Vi kollar helt enkelt om laddningen gjordes innan kortet fanns i Storecheck tabellen. Isåfall var det första
laddningen. Om vi inte kör Activated datum som är äldre än ett år så bör vi inte heller få dubbleter, så att vi kan ha en topup som är första 
laddningen för ett kort, men numret har återanvänts (och då skulle kunna ha ett activated datum som är äldre än kortet).

Detta är väl möjligtvis något vi hade kunnat göra DIREKT i python, istället för med en SQL query. Det är nog kanske till och med enklare
om jag kan lösa att datumen som kommer ut från calendern funkar. Vi får jobba på det.